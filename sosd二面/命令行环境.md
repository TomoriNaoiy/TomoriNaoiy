主要是一些命令行的操作

# 暂停和后台执行进程
jobs 命令会列出当前终端会话中尚未完成的全部任务

可以使用百分号 + 任务编号（jobs 会打印任务编号）来选取该任务如果要选择最近的一个任务，可以使用 $! 这一特殊参数。
```
$ sleep 1000
^Z
[1]  + 18653 suspended  sleep 1000

$ nohup sleep 2000 &
[2] 18745
appending output to nohup.out

$ jobs
[1]  + suspended  sleep 1000
[2]  - running    nohup sleep 2000

$ bg %1
[1]  - 18653 continued  sleep 1000

$ jobs
[1]  - running    sleep 1000
[2]  + running    nohup sleep 2000

$ kill -STOP %1
[1]  + 18653 suspended (signal)  sleep 1000

$ jobs
[1]  + suspended (signal)  sleep 1000
[2]  - running    nohup sleep 2000

$ kill -SIGHUP %1
[1]  + 18653 hangup     sleep 1000

$ jobs
[2]  + running    nohup sleep 2000

$ kill -SIGHUP %2

$ jobs
[2]  + running    nohup sleep 2000

$ kill %2
[2]  + 18745 terminated  nohup sleep 2000

$ jobs

```

# 终端多路复用
当您在使用命令行时，您通常会希望同时执行多个任务。举例来说，您可以想要同时运行您的编辑器，并在终端的另外一侧执行程序。尽管再打开一个新的终端窗口也能达到目的，使用终端多路复用器则是一种更好的办法。

我们可以使用tmux来进行多路复用

tmux 的快捷键需要我们掌握，它们都是类似 <C-b> x 这样的组合，即需要先按下 Ctrl+b，松开后再按下 x。tmux 中对象的继承结构如下：

会话 - 每个会话都是一个独立的工作区，其中包含一个或多个窗口

tmux 开始一个新的会话
tmux new -s NAME 以指定名称开始一个新的会话
tmux ls 列出当前所有会话
在 tmux 中输入 <C-b> d ，将当前会话分离
tmux a 重新连接最后一个会话。您也可以通过 -t 来指定具体的会话
窗口 - 相当于编辑器或是浏览器中的标签页，从视觉上将一个会话分割为多个部分

<C-b> c 创建一个新的窗口，使用 <C-d> 关闭
<C-b> N 跳转到第 N 个窗口，注意每个窗口都是有编号的
<C-b> p 切换到前一个窗口
<C-b> n 切换到下一个窗口
<C-b> , 重命名当前窗口
<C-b> w 列出当前所有窗口
面板 - 像 vim 中的分屏一样，面板使我们可以在一个屏幕里显示多个 shell

<C-b> " 水平分割
<C-b> % 垂直分割
<C-b> <方向> 切换到指定方向的面板，<方向> 指的是键盘上的方向键
<C-b> z 切换当前面板的缩放
<C-b> [ 开始往回卷动屏幕。您可以按下空格键来开始选择，回车键复制选中的部分
<C-b> <空格> 在不同的面板排布间切换

# 配置文件
很多程序的配置都是通过纯文本格式的被称作 点文件 的配置文件来完成

之所以称为点文件，是因为它们的文件名以 . 开头，例如 ~/.vimrc。也正因为此，它们默认是隐藏文件，ls 并不会显示它们

下面展示一些用来配置文件的工具
- bash - ~/.bashrc, ~/.bash_profile
- git - ~/.gitconfig
- vim - ~/.vimrc 和 ~/.vim 目录
- ssh - ~/.ssh/config
- tmux - ~/.tmux.conf

# 可移植性

配置文件的一个常见的痛点是它可能并不能在多种设备上生效

我们可以这样写
```
if [[ "$(uname)" == "Linux" ]]; then {do_something}; fi

# 使用和 shell 相关的配置时先检查当前 shell 类型
if [[ "$SHELL" == "zsh" ]]; then {do_something}; fi

# 您也可以针对特定的设备进行配置

if [[ "$(hostname)" == "myServer" ]]; then {do_something}; fi
```
点文件可以这样编写
```
[include]
    path = ~/.gitconfig_local
```
# 远端设备
看起来是蛮重要的一个点 可能将来会经常使用？

通过这样的命令 我们可以实现远程连接服务器
```
ssh foo@bar.mit.edu
```

服务器可以通过 URL 指定（例如 bar.mit.edu），也可以使用 IP 指定（例如 foobar@192.168.1.42）

# 密钥
这样您就可以避免每次登录都输入密码的麻烦了秘密就可以登录。不过，私钥(通常是 ~/.ssh/id_rsa 或者 ~/.ssh/id_ed25519) 等效于您的密码，所以一定要好好保存它。

密钥生成
使用 ssh-keygen 命令可以生成一对密钥：

ssh-keygen -o -a 100 -t ed25519 -f ~/.ssh/id_ed25519
您可以为密钥设置密码，防止有人持有您的私钥并使用它访问您的服务器。您可以使用 ssh-agent 或 gpg-agent ，这样就不需要每次都输入该密码了。

# 通过 SSH 复制文件
使用 ssh 复制文件有很多方法：

ssh+tee, 最简单的方法是执行 ssh 命令，然后通过这样的方法利用标准输入实现 cat localfile | ssh remote_server tee serverfile。回忆一下，tee 命令会将标准输出写入到一个文件；
scp ：当需要拷贝大量的文件或目录时，使用 scp 命令则更加方便，因为它可以方便的遍历相关路径。语法如下：scp path/to/local_file remote_host:path/to/remote_file；
rsync 对 scp 进行了改进，它可以检测本地和远端的文件以防止重复拷贝。它还可以提供一些诸如符号连接、权限管理等精心打磨的功能。甚至还可以基于 --partial 标记实现断点续传。rsync 的语法和 scp 类似；
# 端口转发
常见的情景是使用本地端口转发，即远端设备上的服务监听一个端口，而您希望在本地设备上的一个端口建立连接并转发到远程端口上。例如，我们在远端服务器上运行 Jupyter notebook 并监听 8888 端口。 然后，建立从本地端口 9999 的转发，使用 ssh -L 9999:localhost:8888 foobar@remote_server 。这样只需要访问本地的 localhost:9999 即可。

# 作业
task1
停止
<img width="786" height="91" alt="image" src="https://github.com/user-attachments/assets/2d25cd37-1eb5-4c04-b1bb-b37ec6c458dc" />
配置文件
```
~ $ mkdir ~/gits/dotfiles   # gits 目录是创建用来存放所有 git 及 github 仓库的目录
   ~ $ git init ~/gits/dotfiles
   # 将本机的配置文件，如 .vimrc/.bashrc/.tmux.conf 等复制进该目录
   ~ $ ls -a ~/gits/dotfiles
   .  ..  .bashrc  .git  .profile  .tmux.conf  .vimrc  .zshrc                      
   # 其中，". .."分别表示本目录及上级目录，".git"为 git 仓库的配置文件，其他文件为存放在仓库中的系统配置文件
```

