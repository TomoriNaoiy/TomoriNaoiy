数据结构和算法
===
由于对python比较熟悉 这里使用python为主进行学习

# 栈
原理就是 后进先出 也就是一个无盖的盒子 从上到下堆放 放进去的再最上面 取出的时候也是拿最上面

操作
### 进栈push
### 出栈pop
### 取栈顶gettop（也就是list[-1]）
```python
Class stack:
  def __init__(self):
    self.stack=[]
  def push(self,element):
    self.stack.append(element)
  def pop(self):
    return self.stack.pop()
  def get_top(self):
    if(len(self.stack))>0:
      return self.stack[-1]
    else:
      return None
```
# 栈的实践----深度优先搜索
这里以迷宫举例 在一个9*9的迷宫中 找到一条出路

以深度优先搜索的思路 便是一条路一直走（1上2右3上4左） 知道4个方向均无路（已走） 便出栈 到上一步继续寻找其他方向 如果继续无路 就再出栈 知道走到出口
```python
maze=   [[1,1,1,1,1,1,1,1,1,1],
		[1,0,0,1,0,0,0,1,0,1],
		[1,0,0,1,0,0,0,1,0,1],
		[1,0,0,0,0,1,1,0,0,1],
		[1,0,1,1,1,0,0,0,0,1],
		[1,0,0,0,1,0,0,0,0,1],
		[1,0,1,0,0,0,1,0,0,1],
		[1,0,1,1,1,0,1,1,0,1],
		[1,1,0,0,0,0,0,0,0,1],
		[1,1,1,1,1,1,1,1,1,1]]
dirs=[lambda x,y:(x+1,y),
    lambda x,y:(x,y+1),
    lambda x,y:(x-1,y),
    lambda x,y:(x,y-1)]
def printmaze(maze,dirs):
    stack=[]
    stack.append((1,1))
    while len(stack)>0:
        curNode=stack[-1]
        if curNode==(8,8):
            print("byd你的路走到头了")
            for p in stack:
                print(p)
            return True
        for dir in dirs:
            nextNode=dir(curNode[0],curNode[1])
            if maze[nextNode[0]][nextNode[1]]==0:
                stack.append(nextNode)
                maze[nextNode[0]][nextNode[1]]=2
                break
        else:
            maze[nextNode[0]][nextNode[1]]=2
            stack.pop()
    else:
        print("byd没有路了")
        return False
printmaze(maze,dirs)
```
![image](https://github.com/user-attachments/assets/2a3cc382-302a-466e-a067-6021be488075)
经典题目 根据深度优先搜索 先进行遍历 每次遇到1 就进行一次dfs 并将周围所有的1变成0 （或者2） 然后继续往下遍历 每次遇到1就岛屿数就加一 然后开始dfs
```python
class Solution:
    def dfs(self,grid,r,c):
            grid[r][c]=0
            l,w=len(grid),len(grid[0])
            for x,y in [(r-1,c),(r+1,c),(r,c+1),(r,c-1)]:
                if 0<=x<l and 0<=y<w and grid[x][y]=="1":
                    self.dfs(grid,x,y)
        
    def numIslands(self, grid: List[List[str]]) -> int:
         l,w=len(grid),len(grid[0])
         ans=0
         for r in range(l):
            for c in range(w):
                if grid[r][c]=="1":
                    ans+=1
                    self.dfs(grid,r,c)
         return ans
 ```
# 队列
原理就是 先进先出 也就是一个单向通道 一边只能进 一边只能出

因为如果正常列表 会出现空间被占用 效率不高

因此我们多用环线队列
```python
#front 队首
#rear 队尾
```
### 队首指针前进 front = （front+1）%maxsize
### 队尾rear = （rear+1）%maxsize
### 队空 rear==front
### 队满（rear+1）%maxsize==front

```python
Class Queue:
  def __init__(self,size=100):
    self.queue=[0 for _ in range(size)]
    self.size=size
    self.rear=0
    self.front=0
  def push(self,element):
    if not is_filled():
      self.rear=(self.rear+1)%self.size
      self.queue[self.rear]=element
    else:
      ()=()
  def pop(self):
    if is_empty():
      self.front=(self.front+1)%self.size
      return self.queue[self.front]
    else:
      ()=()
  def is_empty(self):
    return self.rear==self.front
  def is_filled(self)
    return (self.rear+1)%self.size==self.front
```
# 更简单的实现
当然就是独属于我们pythoner的方法 调用了
```python
from collections import deque
q=deque()
a.append()
q.popleft()
```
### 迷宫实现 队列--广度优先搜索
```python
from collections import deque
maze= [[1,1,1,1,1,1,1,1,1,1],
		[1,0,0,1,0,0,0,1,0,1],
		[1,0,0,1,0,0,0,1,0,1],
		[1,0,0,0,0,1,1,0,0,1],
		[1,0,1,1,1,0,0,0,0,1],
		[1,0,0,0,1,0,0,0,0,1],
		[1,0,1,0,0,0,1,0,0,1],
		[1,0,1,1,1,0,1,1,0,1],
		[1,1,0,0,0,0,0,0,0,1],
		[1,1,1,1,1,1,1,1,1,1]]
dirs=[lambda x,y:(x+1,y),
    lambda x,y:(x,y+1),
    lambda x,y:(x-1,y),
    lambda x,y:(x,y-1)]
def path_print(path):
	curNode=path[-1]
	real_path=[]
	while curNode[2]!=-1:
		real_path.append(curNode[0:2])
		curNode=path[curNode[2]]
	real_path.append(curNode[0:2])
	
	for i in reversed(real_path):
		print(i)
def path_find(x1,y1):
	quque=deque()
	path=[]
	quque.append((x1,y1,-1))
	while len(quque)>0:
		curNode=quque.popleft()
		path.append(curNode)
		if curNode[0:2]==(8,8):
			print("到了")
			path_print(path)
			return True			
		for dir in dirs:
			nextNode=dir(curNode[0],curNode[1])
			if maze[nextNode[0]][nextNode[1]]==0:
				quque.append((nextNode[0],nextNode[1],len(path)-1))
				maze[nextNode[0]][nextNode[1]]=2
	else:
		print("无路可走")
path_find(1,1)
```
相对于栈的优势 队列在求此类问题上 最大的优势是能获得**最短路径**
![image](https://github.com/user-attachments/assets/c6126142-efd3-4ccf-88dd-4ba1809b1405)
经典bfs题 我自己写的感觉完全没问题 但是洛谷会报错 不知道为啥 当思路就是这样 
```python
from collections import deque
class Solution:
    def __init__(self,mg,i,j,n):
        self.mg=mg
        self.i,self.j=i-1,j-1
        self.num=1
        self.n=n
        self.visited = [[0 for _ in range(n)] for _ in range(n)]

    def bfs(self):
        queue=deque()
        queue.append((self.i,self.j))
        self.visited[self.i][self.j]=2# 这里是一个注意点 不要直接标记迷宫 应该另外设一个数组
        
        while len(queue)>0:#以空为标准 后面会一个个加入 知道找不到
            curnode=queue.popleft()
            
            if self.mg[curnode[0]][curnode[1]]==0:

                for di,dj in [(0,-1),(1,0),(-1,0),(0,1)]:
                    nextnode=(curnode[0]+di,curnode[1]+dj)
                    if nextnode[0]>=0 and nextnode[1]>=0 and nextnode[0]<self.n and nextnode[1]<self.n and mg[nextnode[0]][nextnode[1]]==1 and self.visited[nextnode[0]][nextnode[1]]==0:
                        queue.append(nextnode)
                        self.num+=1
                        self.visited[nextnode[0]][nextnode[1]]=2
                       
            elif mg[curnode[0]][curnode[1]]==1:

                for di,dj in [(0,-1),(1,0),(-1,0),(0,1)]:
                    nextnode=(curnode[0]+di,curnode[1]+dj)
                    if nextnode[0]>=0 and nextnode[1]>=0 and nextnode[0]<self.n and nextnode[1]<self.n and mg[nextnode[0]][nextnode[1]]==0 and self.visited[nextnode[0]][nextnode[1]]==0:
                        queue.append(nextnode)
                        self.num+=1
                        self.visited[nextnode[0]][nextnode[1]]=2
        return self.num
n,m=map(int,input().split())
mg=[]
new=[]
for i in range(n):
    temp=input()
    temp_list=[]
    for j in temp:
        temp_list.append(int(j))
    mg.append(temp_list)
for _ in range(m):
    i,j=map(int,input().split())
    new.append((i,j))
for kkk in new:
    solution=Solution(mg,kkk[0],kkk[1],n)
    print(solution.bfs())
    
```

# 链表
一个彼此相连的线性结构

链表的每个单位包含两个部分 内容部分和指针部分

在py中 每个节点也就是一个对象
```python
 class node:
     def __init__(self,value):
         self.value=value
         self.next=None
 class line:
     def __init__(self):
         self.head=None
     def creat(self,value):
         newnode=node(value)
         if not self.head:
             self.head=newnode
             return
         cur=self.head
         while cur.next:
             cur=cur.next
         cur.next=newnode
     def printf(self):
         cur=self.head
       while cur is not None:
             print(cur.value,end=" ")
             cur=cur.next
     def link(self,value,position):
         cur=self.head
         new=node(value)
         if position == 0:
            new.next=self.head
             self.head=new
             return
         cur=self.head
         for _ in range(position-1):
             cur=cur.next
         new.next=cur.next
         cur.next=new
     def delete(self,value):
         cur=self.head
         while cur.next.value!=value:
             cur=cur.next
         cur.next=cur.next.next
        
```
# 哈希表
哈希表实际就是一个带有哈希函数的链表集

由于正常的集合 列表 需要纯的位数多 可能会需要开一个巨大的空间 但是许多位置是空出来的 占用了内存 因此诞生哈希表 

哈希表将下标使用h（x）处理 也就是说列表中 下标是k 哈希表中 下标就是h（k）

常用的哈希函数之一 k%size

也就是开一个大小为7的链表集 

**为何要开链表？**
因为如果开k%size 这个哈希表每个位置只能放入一个 那么同时出现两个相同的位置的数就会出现哈希冲突例如 0 和size最后得到的下标都是0 那么久使用链表 将哈希冲突的值连在一起
# 定义链表节点类
```python
class ListNode:
    def __init__(self, key, value):
        self.key = key
        self.value = value
        self.next = None

# 定义哈希表类
class HashTable:
    def __init__(self, size):
        # 初始化哈希表的大小和存储列表
        self.size = size
        # 每个位置初始化为 None，表示还没有元素
        self.table = [None] * size

    def _hash(self, key):
        # 哈希函数，将键转换为索引
        return hash(key) % self.size

    def put(self, key, value):
        # 计算键对应的哈希索引
        index = self._hash(key)
        # 获取该索引位置的链表头节点
        head = self.table[index]
        current = head
        # 遍历链表，查找是否已存在该键
        while current:
            if current.key == key:
                # 如果键已存在，更新值
                current.value = value
                return
            current = current.next
        # 如果键不存在，创建新节点并插入到链表头部
        new_node = ListNode(key, value)
        new_node.next = head
        self.table[index] = new_node

    def get(self, key):
        # 计算键对应的哈希索引
        index = self._hash(key)
        # 获取该索引位置的链表头节点
        head = self.table[index]
        current = head
        # 遍历链表，查找该键
        while current:
            if current.key == key:
                return current.value
            current = current.next
        # 如果键不存在，返回 None
        return None

    def remove(self, key):
        # 计算键对应的哈希索引
        index = self._hash(key)
        # 获取该索引位置的链表头节点
        head = self.table[index]
        prev = None
        current = head
        # 遍历链表，查找该键
        while current:
            if current.key == key:
                if prev:
                    # 如果不是头节点，将前一个节点的 next 指向当前节点的下一个节点
                    prev.next = current.next
                else:
                    # 如果是头节点，更新头节点为当前节点的下一个节点
                    self.table[index] = current.next
                return
            prev = current
            current = current.next

# 使用自定义哈希表
hash_table = HashTable(10)
hash_table.put('apple', 1)
hash_table.put('banana', 2)
print(hash_table.get('apple'))  # 输出: 1
hash_table.remove('banana')
print(hash_table.get('banana'))  # 输出: None
```\
# 树
一个可以由递归定义的数据结构
```python
class Node:
	def __init__(self,name,dir):
		self.name=name
		self.dir=dir
		self.children=[]
		self.parent=None
node=Node()
node2=Node()
node.name="1"
node2.name="2"
node.children.append(node2)
node2.parent=node
```
## 二叉树
也就是只有至多两个子节点的数
```python
class BitreeNode:
	def __init__(self,data):
		self.data=data
		self.rchildren=None
		self.lchildren=None
```
分为左节点和右节点

### 遍历二叉树
递归遍历
```python
def print_tree(root):
	if root:
		print(root.data)
		print_tree(root.lchildren)
		prnt_tree(root.rchildren)

### 二叉搜索树
所有父节点都大于左子节点 右子节点大于父节点的二叉树


```python
class BitreeNode:
	def __init__(self,data):
		self.data=data
		self.rchildren=None
		self.lchildren=None
class BST:
 	def __init__(self):
		self.root=None
	def insert(self,node,val):
		if not node:
			node=BitreeNode(val)
		elif val<node.data:
			node.lchild=self.insert(node.lchild,val)
		elif val>=node.data:
			node.rchild=self.insert(node.rchild,val)
	return node

#插入
def query(self,node,val):
	if not node:
		return None
	if node.data<val:
		return self.query(node.rchild,val)
	elif node.data>val:
		return self.quert(node.lchild,val)
	else:
		return 	node
```
**删除**
1.单子叶 直接删除

2.有一个孩子的父结点 将这个节点的孩子和父亲相连

3.两个汉字 找右子树的最小节点替换该结点 并删除该节点
```python
def remove_node1(self,node):
	if nodt node.parent:
		self.root=None
	if node == node.parent.lchild#父亲的什么孩子
		node.parent.lchild=None
		node.parent=None
	#else
	return node
def remove_node2(self,node):
	if  not node.parent:
		self.root=node.lchild
		node.lchild.parent=None
	elif node==node.parent.lchild:
		node.parent.lchild=node.lchild
		node.lchild.parent=node.parent
	else:
	return node
def remove_node3(self,node):
	min_node=node.rchild:
	while min_node.lchild:
		min_node=min_node.lchild
	node.data=min_node.data
	#然后用1的方法 删掉这个子节点
```
### 二叉树的遍历
![image](https://github.com/user-attachments/assets/648c01a2-0baf-4d5e-a6be-6c1c786299f7)
如果你按照 根节点 -> 左孩子 -> 右孩子 的方式遍历，即「先序遍历」，每次先遍历根节点，遍历结果为 1 2 4 5 3 6 7；

同理，如果你按照 左孩子 -> 根节点 -> 右孩子 的方式遍历，即「中序序遍历」，遍历结果为 4 2 5 1 6 3 7；

如果你按照 左孩子 -> 右孩子 -> 根节点 的方式遍历，即「后序序遍历」，遍历结果为 4 5 2 6 7 3 1；

最后，层次遍历就是按照每一层从左向右的方式进行遍历，遍历结果为 1 2 3 4 5 6 7。


```python
#前序
def dfs(root):
	if not root:
		return
	print(root.value)
	dfs(root.lchildren)
	dfs(root.rchildren)
#中序
只要改变位置即可
def dfs(root):
	if not root:
		return
	dfs(root.lchildren)
	print(root.value)
	dfs(root.rchildren)
#同样 后序 只需要
	dfs(root.l)
	dfs(root.r)
	print()
```
![image](https://github.com/user-attachments/assets/236d7bf0-c530-4815-92e5-ba5ab16f8d0a)
最基础的树 基本没有思路 先训练对树的构建
```python
class tree:
    def __init__(self,val=0,lch=None,rch=None)://树结点
        self.val=val
        self.lch=lch
        self.rch=rch
def buildtree(n,children)://构建树
    node=[tree(i) for i in range(n+1)]//先创建一个线性树列表 
    for i in range(1,n+1):
        l,r=children[i]
        if l != 0:
            node[i].lch=node[l]//对每个节点的分支进行赋值
        if r != 0:
            node[i].rch=node[r]
    return node[1]
def qx(root):
    if root:
        print(root.val,end=" ")
        qx(root.lch)
        qx(root.rch)
def zx(root):
    if root:
       
        zx(root.lch)
        print(root.val,end=" ")
        zx(root.rch)

def hx(root):
    if root:
        
        hx(root.lch)
        hx(root.rch)
        print(root.val,end=" ")
         
n=int(input())
Children={}
for i in range(1,n+1):
    l,r=map(int,input().split())
    Children[i]=(l,r)

root=buildtree(n,Children)
qx(root)
print()
zx(root)
print()
hx(root)
```
![image](https://github.com/user-attachments/assets/d283fdf5-b011-469a-b462-38755f3ad736)
算是正式做的第一道树论 虽然依旧很简单 但我还是不会写 看了ai之后勉强弄懂 自己大概写了一下
其实这题的思路应该是 先判断最大的s 是f还是b i然后切半 分别查看时f还是b i 然后再分别切 并在这个过程中不断创建树节点 从而完成数的构造 然后就是正常的后序遍历 但是这题让我看到一个巨大的问题就是洛谷里面的输入需要strip（） 不然就错误 代码如下
```python
class tree:
    def __init__(self,ty,lch=None,rch=None):
        self.ty=ty
        self.lch=lch
        self.rch=rch
def build_tree(s):
    if len(s)==1:
        if s=="0":
            return tree("B")
        else:
            return tree("I")//切到剩一个 就直接返回一格节点
    else:
        mid=len(s)//2
        l=build_tree(s[:mid])
        r=build_tree(s[mid:])
        if l.ty=="B" and r.ty=="B":
            root=tree("B")
        elif l.ty=="I" and r.ty=="I":
            root=tree("I")   
        else:
            root=tree("F")
        root.lch=l
        root.rch=r
    return root
def hx(root):
    if root:
        hx(root.lch)
        hx(root.rch)
        print(root.ty,end="")
n=int(input())
num=input().strip()# 1及其坑爹 不加strip就答案错误（还不是报错）
root=build_tree(num)
hx(root)
```
![image](https://github.com/user-attachments/assets/de5f2bfb-9b38-41cb-8c54-40aae7cebfcf)
树论 构造树的过程上面以及有提 这一题最重要的思路是寻找最小权重 我们用到**佛洛依德算法** 

 一、什么是佛洛依德算法？
 
Floyd-Warshall 算法 是一种 动态规划算法，用于求任意两个顶点之间的最短路径。适用于 稠密图、小规模图。

🧠 核心思想：
通过每一个点 
𝑘
k 来“尝试”更新从点 
𝑖
i 到点 
𝑗
j 的最短距离。

转移方程：

dist
[
𝑖
]
[
𝑗
]
=
min
⁡
(
dist
[
𝑖
]
[
𝑗
]
,
 dist
[
𝑖
]
[
𝑘
]
+
dist
[
𝑘
]
[
𝑗
]
)
dist[i][j]=min(dist[i][j], dist[i][k]+dist[k][j])
也就是说：

原本从 
𝑖
i 到 
𝑗
j 需要走一条路径，

现在考虑一个中间点 
𝑘
k，看下从 
𝑖
i → 
𝑘
k → 
𝑗
j 是否更短。

如果是，就更新。
而在这一题中 由于是树 则需要把不相邻的两个结点距离设置为无穷 因为无法到达 相邻是1 自己到自己是0
```python
class tree:
    def __init__(self, data=0, lch=None, rch=None):
        self.data = data
        self.lch = lch
        self.rch = rch
        self.num = 0  # 增加人口字段

def build_tree(n, cache):
    link = [tree() for _ in range(n + 1)]
    for i in range(1, n + 1):
        num, l, r = cache[i]
        link[i].num = num  # 存储人口
        if l != 0:
            link[i].lch = link[l]
        if r != 0:
            link[i].rch = link[r]
    return link[1], link  # 返回根节点和所有节点引用

INF = float('inf')

n = int(input())
cache = [(0, 0, 0)]
for _ in range(n):
    num, l, r = map(int, input().split())
    cache.append((num, l, r))

root, nodes = build_tree(n, cache)
# 由于需要使用佛洛依德算法算法 这里还是使用线性树列表 因此把整个列表返回
# Step 1: 初始化邻接矩阵
dist = [[INF] * (n + 1) for _ in range(n + 1)]
for i in range(1, n + 1):
    dist[i][i] = 0  # 自己到自己距离为 0
    _, l, r = cache[i]
    if l != 0:
        dist[i][l] = dist[l][i] = 1
    if r != 0:
        dist[i][r] = dist[r][i] = 1

# Step 2: Floyd 算法求最短路径 佛洛依德算法核心
for k in range(1, n + 1):
    for i in range(1, n + 1):
        for j in range(1, n + 1):
            if dist[i][j] > dist[i][k] + dist[k][j]:
                dist[i][j] = dist[i][k] + dist[k][j]

# Step 3: 枚举每个节点作为医院
min_cost = INF
for hos in range(1, n + 1):#分别从每个结点开始
    cost = 0
    for i in range(1, n + 1):#遍历每个树结点
        cost += nodes[i].num * dist[hos][i]
    min_cost = min(min_cost, cost)

print(min_cost)
```	
![image](https://github.com/user-attachments/assets/c2d7bf50-5848-410c-ba9d-53dd42683c71)
异或树问题 具体思路 由于不是二叉树 我们无法建造一个树结构 因此选择构造无向图 然后根据dfs 存储从根到每个结点的异或和（在树中 两点的路径唯一）
然后根据要求的边 只要计算num【a】^num[b] （重复路径被异或消掉 只剩a-》b的路径异或和） 为什么不直接求a-b 因为时间复杂度高
```python
import sys
#sys.setrecursionlimit(10**6)

data = sys.stdin.read().split()
idx = 0

n = int(data[idx])
idx += 1

tree = [[] for _ in range(n + 1)]

for _ in range(n - 1):
    u = int(data[idx])
    v = int(data[idx + 1])
    w = int(data[idx + 2])
    idx += 3
    tree[u].append((v, w))
    tree[v].append((u, w))

xor_path = [0 for _ in range(n + 1)]
visit = [False for _ in range(n + 1)]

def dfs(root, nor_num):
    xor_path[root] = nor_num
    visit[root] = True
    for v, w in tree[root]:
        if not visit[v]:
            dfs(v, nor_num ^ w)

dfs(1, 0)

m = int(data[idx])
idx += 1

for _ in range(m):
    a = int(data[idx])
    b = int(data[idx + 1])
    idx += 2
    print(xor_path[a] ^ xor_path[b])
```
至于为什么要用sys 因为shabi洛谷是一次性输入 不然就报错
不过根据这题能得到一个思路 又明确父子关系或者顺序结构的才建树 这里只需要构建一个图（树）他是无根无向的

-有序二叉树、堆等	构建 TreeNode 对象	使用 left/right 等指针

-图论中的「树」	用邻接表	tree[u].append((v, w))
![image](https://github.com/user-attachments/assets/12161be9-066c-40f5-8c9d-e57ad918cdb4)
出生题目 同样的逻辑c++全对python爆三分之一 给我气笑了
好了话不多说 这也是一提经典的无向树 因此根据上一题的经验 我们依旧创建一个邻接表

值得一提的是 collections里面有一个defaultdict 可以在没有一个key的时候自动创建而不是报错（的字典）
因此我们这样写
```python
def build(n, road):
    tree = defaultdict(list)
    for a, b, c in road:
        tree[a].append((b, c))
        tree[b].append((a, c))
    return tree
```
然后就是计算每一个桥的cost 因为我们要计算联通块两边的大小的差 就是size-（n-size）也就是说我们只需要遍历一个方向就可以了

因此思路就是对一边进行dfs 每有一个结点就+1 然后计算每个桥cost
```python
import sys
sys.setrecursionlimit(10**6)
from collections import defaultdict

n = int(input())

# 构建图：使用 defaultdict 让你不需要判断 key 是否存在
def build(n, road):
    tree = defaultdict(list)
    for a, b, c in road:
        tree[a].append((b, c))
        tree[b].append((a, c))
    return tree

def dfs(u, graph, n, visited, total_cost):
    visited[u] = True
    sz = 1
    for v, c in graph[u]:
        if not visited[v]:
            sub_sz = dfs(v, graph, n, visited, total_cost)
            total_cost[0] += c * abs(n - 2 * sub_sz)
            sz += sub_sz
    return sz

road = []
for _ in range(n - 1):
    a, b, c = map(int, input().split())
    road.append((a, b, c))

graph = build(n, road)
visited = [False] * (n + 1)
total_cost = [0]

dfs(1, graph, n, visited, total_cost)
print(total_cost[0])
```
# 在继续下一题之前 先学习一个 何为树
![image](https://github.com/user-attachments/assets/3c7bb15b-b9bc-483d-8378-e56f61624150)
将这样一个无向图中把各个结点无环地连接起来 就是树
那么生成树呢 就是将无向图中所有结点连接起来 形成一个树 

那么衍生出来的算法 最小生成树 就是希望花费最小的代价 将所有结点相连 

而实现最小生成树的算法有两种 prim和Kruskal

第一 prim 
思路

从某个点出发，每次选择一条连接当前已访问点集与未访问点之间权值最小的边。

不断扩展，直到所有点都被包含。

🪜 实现步骤：
从任意一点出发，把它标记为访问过。

把与它相连的边都放进最小堆（heap）。

每次从堆里取出当前最小的边，如果这条边连接的点没被访问过，就选它。

重复步骤 2~3，直到所有点都被访问。

![image](https://github.com/user-attachments/assets/e9a579a4-856c-4227-aa96-95cd74cc2507)
以这一题为例 在说prim之前 先说一下pyhton的headp库 是一个最小堆库 可以帮我们加入和推出最小堆 方便我们进行选择
```python
import heapq

def min_cost(A, B, K):
    visited = [False] * B
    min_heap = []

    # 初始化：每个商品可以原价买，相当于“虚拟边”
    for i in range(B):
        heapq.heappush(min_heap, (A, i))

    total_cost = 0
    count = 0  # 统计加入了多少个商品

    while count < B:
        cost, u = heapq.heappop(min_heap)
        if visited[u]:
            continue
        visited[u] = True
        total_cost += cost
        count += 1

        # 加入与 u 相连的优惠边
        for v in range(B):
            if not visited[v] and K[u][v] > 0:
                heapq.heappush(min_heap, (K[u][v], v))

    return total_cost
a,b=map(int,input().split(" "))
k=[list(map(int,input().split(" "))) for _ in range(b)]
print(min_cost(a,b,k))
```
这题的思路就是 从0 0开始 然后通过visit标记 把四周的边都加入堆 然后每次弹出最小堆 然后在加（感觉有点像dfs+贪心？？）

接下来是kruskal算法 同样是寻找最小生成树 库莱西裤的算法更加直观 将所有边排序 然后从小到大放进图里面 如果不成环就继续 成环就不放（保证可以全连接起来）

那么如何判断是否成环呢 就要引入我们的并查集了
```python
def find(parent, i):
    if parent[i] != i:
        parent[i] = find(parent, parent[i])
    return parent[i]

def union(parent, rank, u, v):
    pu, pv = find(parent, u), find(parent, v)
    if pu == pv:
        return False
    if rank[pu] > rank[pv]:
        parent[pv] = pu
    elif rank[pu] < rank[pv]:
        parent[pu] = pv
    else:
        parent[pu] = pv
        rank[pv] += 1
    return True
```
这就是基本框架 一个find函数（包含路径压缩） 一个合并（用于在库莱虚库里面判断是否成环） 为什么呢 

并查集就是类似于一将一个个树形结构 通过祖先（根） 将其合并成一个大树 如果已经是同一个根了 说明连在一起了 那就成环了 不可以 因此判断根不同 同时通过路径压缩和rank排序进行优化

那话有说回来库莱虚库算法 对于上面题目
```python
def find(parent, i):
    if parent[i] != i:
        parent[i] = find(parent, parent[i])
    return parent[i]

def union(parent, rank, u, v):
    pu, pv = find(parent, u), find(parent, v)
    if pu == pv:
        return False
    if rank[pu] > rank[pv]:
        parent[pv] = pu
    elif rank[pu] < rank[pv]:
        parent[pu] = pv
    else:
        parent[pu] = pv
        rank[pv] += 1
    return True

def kruskal_min_cost(A, B, K):
    edges = []

    # 1. 原始优惠边
    for i in range(B):
        for j in range(i + 1, B):
            if K[i][j] != 0:
                edges.append((K[i][j], i, j))

    # 2. 虚拟边：每个商品和虚拟节点连接，边权为 A（即单买）
    virtual_node = B  # 添加一个第B个虚拟点
    for i in range(B):
        edges.append((A, i, virtual_node))

    edges.sort()

    parent = list(range(B + 1))
    rank = [0] * (B + 1)
    total_cost = 0
    count = 0

    for cost, u, v in edges:
        if union(parent, rank, u, v):
            total_cost += cost
            count += 1
            if count == B:  # 需要连通 B 个商品，必须连 B 条边（包括虚拟点）
                break

    return total_cost

# 输入处理
A, B = map(int, input().split())
K = [list(map(int, input().split())) for _ in range(B)]

print(kruskal_min_cost(A, B, K))
```
大致思路就这样 后面坐题巩固一下
算法
========
# 贪心算法 
远近闻名的算法

开始前 先想想 我们为什么要使用算法 

正常来说 以人的思路来做 很可能将一个问题复杂化 又或者是使用的思路会具有很大的复杂度 而使用算法能大大的帮我门提高程序效率和降低占用资源

**那么开始**
贪心算法的基本思路就是 选取每个部分的局部最优解（也就是不从整体上来考虑 而是对部分求最优解）从而使得所有的局部最优解合成一个整体最优解 但是这样的结果有时不会是最优的 因此贪心不一定在所有场景都有效果 而贪心算法的特点是不会对以及做过选择的部分进行回溯思考
### 贪心的步骤
1. 确定问题的优化目标：明确需要最大化或最小化的目标。
2. 确定贪心策略：定义每一步的局部最优选择。
3. 证明贪心策略的正确性：确保贪心选择能够导致全局最优解。
4. 实现算法：根据贪心策略编写代码。
5. 验证结果：检查算法是否得到了正确的结果。

通过一个经典的例子举例 要购买股票并获得最大的受益 
七天内的股值为[7,1,5,3,6,4,2]
那么贪心的思路就是 **如果今天买明天卖就有受益 那就今天买** 这就是局部的最优
```python
gp=[7,1,5,3,6,4]
profit=0
for i in range(len(gp)):
	if gp[i]<gp[i+1]:
		profit+=gp[i+1]-gp[i]
```
接下来是喂小孩子的例子
【1，2，3】这是有的饼干
【1，2】这是小孩的饱食度
要喂饱尽可能多的小孩 

贪心算法的思路就是 从最好饱的开始 那就是1喂1 2喂2
```python
children=[1,2]
cookies=[1,2]
child=0
cookie=0
while(child<len(chileren) and cookie<len(cookies)):
	if children[child]<=cookies[cookie]:
		child+=1
	cookie+=1
```
第三个例子 
去掉部分区间 使得所有区间没有重合
【1,2】,[1,3],[2,4]
我们的做法是 先**排序**（很重要的步骤 几乎所有都要贪心排序） 然后根据保留结尾最小的区间 并且与前面的区间没有重合的部分
![image](https://github.com/user-attachments/assets/1219a12f-53a1-4494-bb8f-2a73fe0dbdd2)
这一题 贪心算法就是**能种便种**
```python
class Solution:
    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:
        flowerbed=[0]+flowerbed+[0] #本实现最大亮点 由于底下的做法可能回忽略掉两边墙壁（只要有一边为1）因此我们可以在原列表的两边加上0  将墙壁模拟成正常的部分比如[0,0,1,1,0]
        for i in range(1,len(flowerbed)-1):
           
            
            if flowerbed[i]!=1 and flowerbed[i+1]!=1 and flowerbed[i-1]!=1:
                flowerbed[i]=1
                n-=1
      
        return n<=0

```
![image](https://github.com/user-attachments/assets/da87b3bd-b9f3-46ce-9c47-9403df827988)
一个贪心题 从贪心的角度入手 就是使得每一个人走的距离都是最近（最远）的 但是这里有一点思维跳脱 就是看起来的碰撞反向 可以当作是两者灵魂互换 也就是根本没有换 按着原方向前进 那么就可以理所应当的使用贪心了
```python
class solution:
    def __init__(self,l,n,a):
        self.l,n,a=l,n,a
        self.less_time=0
        self.most_time=0
    def tx_less(self)://只需要判断离那个方向远  就选择他的方向即可 思路很简单
        if n==0:
            return 0

        time=[]
        for i in a:
            if abs(i)<=abs(i-self.l-1):
                time.append(i)
            elif abs(i)>abs(i-self.l-1):
                time.append(abs(i-self.l-1))
        try:
            self.less_time=max(time)//由于木桶效应  取最久的那个
        except:
            self.less_time=time[0]
        return self.less_time
    def tx_most(self):
        if n==0:
            return 0
        time=[]
        for i in a:
            if abs(i)>=abs(i-self.l-1):
                time.append(i)
            elif abs(i)<abs(i-self.l-1):
                time.append(abs(i-self.l-1))
        try:
            self.most_time=max(time)
        except:
            self.most_time=time[0]
        return self.most_time
```
        














l=int(input())
n=int(input())
if n!=0:
    a=list(map(int,input().split()))
else:
    a=[]

solution=solution(l,n,a)
print(solution.tx_less(),end=" ")
print(solution.tx_most())



# 动态规划
又是一个及其重要的算法 以我的理解 核心就是
1. 找到状态转移方程 人话来说 就是当前节点的结果必须根据前一次或若干次结果得到
2. 存储中间结果 也就是俗话说的记忆化搜索 为了避免重复计算 将计算结果存储 然后每次检查 若有就直接返回 没有就计算后存入
再讲的通俗一点 就是逐步减小问题的规模 例如求f（n） 就缩减为跟f（n-1）的关系 然后以此类推 知道得到结果

理论结束 实践开始
nums=[1,5,2,4,3]
找出最长的递增的子数列

正常想法 ：暴力
也就是使用嵌套循环 
![image](https://github.com/user-attachments/assets/93624830-bfeb-4b59-a78a-882e52fb8b62)
通过遍历每个树 再获得最长
```python
def L(num,i):
	if i==len(num)-1:
		return 1
	#遍历倒末尾的时候停止
	max_len=1
	for j in range(i+1,len(nums)):
		if num[j]>num[i]:
			max_len=max(max_len,L(nums,j)+1)
	return max_len
```
这里就是用递归的想法完成的实现（其实已经有部分动态规划的想法在里面了）
动态规划的做法
```
memo={}

def L(num,i):
	if i in memo:
		return memo[i]
	if i==len(num)-1:
		return 1
	#遍历倒末尾的时候停止
	max_len=1
	for j in range(i+1,len(nums)):
		if num[j]>num[i]:
			max_len=max(max_len,L(nums,j)+1)
	memo[i]=max_lem
	return max_len
```
很明显 这里相对于递归的做法 我们加入了记忆化搜索 这样子将效率大大提高

那么不使用递归呢 

![image](https://github.com/user-attachments/assets/84f03a19-0b34-4d17-9229-f6178b14cb2b)
便是如此 这样就是完成的动态规划的算法 通过类似数学归纳法的方法 通过对逐渐减小的规模使用相同的函数返回 知道得到最终结果
```python
def length_of_LIS(nums):
	n=len(nums)
	L=[1 for _ in range(5)]
	for i in reversed(range(n)):
		for j in range(i+1,n):
			if nums[j]>nums[i]:
				L[i]=max(L[i],L[j]+1)
	return max(L)
```
![image](https://github.com/user-attachments/assets/3c0b34a3-15d2-42df-93ac-b8cc67a11e3f)
最最简单且经典的动态规划
```python
class solution:
    def jc(self,num):
        if num==1:
            return 1
        return num*self.jc(num-1)
    def s(self,val):
        if val==1:
            return 1
        return self.jc(val)+self.s(val-1)
so=solution()
n=int(input())
print(so.s(n))
```

![image](https://github.com/user-attachments/assets/4b04e849-b5aa-4cbe-9ac1-c2c82170632e)
这题使用动态规划 要找到最小值 只需要在每一步取min即可
```python
class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        n=len(cost)
        dp=[0]*(n+1)
        for i in range(2,n+1):
            dp[i]=min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2])
        return dp[n]
```
![image](https://github.com/user-attachments/assets/5ee4793d-663a-4235-af59-1b2cac642338)
这一题使用两层线性动态规划 一层时间 一层空间 

由于球只能来自于左边或右边 

方程为dp[i][j]=dp[i-1][j-1]+dp[i-1][j+1]

```python
class Solution:
    def where(self, n, m):
        # 初始化 dp 数组
        dp = [[0] * n for _ in range(m + 1)]
        dp[0][0] = 1  # 初始时，球在小蛮手里

        # 动态规划计算
        for i in range(1, m + 1):
            for j in range(n):
                # 球可以从左边或右边的同学传过来
                dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]

        # 返回球传了 m 次后回到小蛮手里的方法数
        return dp[m][0]

# 测试
s = Solution()
print(s.where(3, 3))  # 输出 2
```
![image](https://github.com/user-attachments/assets/06bf40b0-d786-4a5c-9048-e165df2c23ba)
这题想法是

dp[j] 表示在时间 j 内可以采到的草药的最大总价值。

初始化时，dp 数组的所有值都为 0，因为初始时没有采任何草药。

遍历草药：



对于每一种草药，更新 dp 数组。

从后往前更新是为了避免重复计算（即保证每种草药只能选一次）。

状态转移方程：

dp[j] = max(dp[j], dp[j - 时间] + 价值)：选择采或不采当前草药，取最大值。
```python
def max_herb_value(total_time, num_herbs, herbs):
    dp = [0] * (total_time + 1)  # dp[i] represents the maximum value for time i
    for time, value in herbs:
        for t in range(total_time, time - 1, -1):
            dp[t] = max(dp[t], dp[t - time] + value)
    return dp[total_time]

# Input
T, M = map(int, input().split())
herbs = []
for _ in range(M):
    time, value = map(int, input().split())
    herbs.append((time, value))

# Output
print(max_herb_value(T, M, herbs))
```
可以看到，容量大的时候的值取决于容量小的时候的值，从而不断被正确更新，所以用一维 dp 的时候，j 的循环必须是从大到小逆序开始的，逆序，就防止了一个物品放入多次！！！否则...........
dp[i][j]=max(dp[i−1][j−w[i]])+v[i],dp[i−1][j])这是二维的方程 为了减小空间 我们去掉i 只使用一维
![image](https://github.com/user-attachments/assets/e46e3ac1-bcd9-44bd-b521-05b5f329bee4)
经典题 思路蛮简单 就是一个点从前面两个位置来 使用递归
```python
class solution:
    def __init__(self,x0,y0,x1,y1):
        self.x0=x0
        self.y0=y0
        self.dp=[[-1 for _ in  range(y0+1)] for _ in range(x0+1)]# 这里注意 大小假如6 6 那么我们要多开一格 方便我们后面使用【6】【6】
        for dx, dy in [(-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2), (-1, 2), (-2, 1),(0,0)]:
            nx, ny = x1 + dx, y1 + dy
            if 0 <= nx <= x0 and 0 <= ny <= y0:
                self.dp[nx][ny] = 0  
        
    def path(self,x,y):
        
        if x==0 and y==0:
            return 1//到起点 返回1
        if x<0 or y<0:
            return 0 //超过边界或者被拦住 就返回0
        if self.dp[x][y]==0 :
            return 0
        if self.dp[x][y]!=-1: 如果以及计算过 就直接返回 
            return self.dp[x][y]
        
        self.dp[x][y]=self.path(x-1,y)+self.path(x,y-1)
        return self.dp[x][y]
        
z=list(map(int,input().split()))
x0,y0,x1,y1=z[0],z[1],z[2],z[3]
solution=solution(x0,y0,x1,y1)
print(solution.path(x0,y0))
```
![image](https://github.com/user-attachments/assets/c4a47b20-6601-48e9-968f-d8cdb608fbd7)
经典背包问题 两种选择 选或不选 取v最小值
状态转移方程f(v,n)=min(f(v,n-1),f(v-w[n-1],n-1))//这里要从n-1开始选 而不是w【n】因为索引从0开始 如果是n的话 开始的时候就超了
```python
class solution:
    def dp(self,V,w,v,num):
        if num==0:
            return v//没得选的时候 返回v
        if v<w[num-1]:
            return self.dp(V,w,v,num-1)//如果这个物品拿不下 就直接不拿
        if V[v][num]!=-1:
            return V[v][num] //如果选择过 就跳过
        V[v][num]=min(self.dp(V,w,v,num-1),self.dp(V,w,v-w[num-1],num-1))//拿或不拿 选择最小的一个
        return V[v][num]


   
v=int(input())
num=int(input())
w=[]
V=[[-1 for _ in range(num+1)] for _ in range(v+1)]//开的时候多开一格
for _ in range(num):
    w.append(int(input()))
solution=solution()
print(solution.dp(V,w,v,num))

```
![image](https://github.com/user-attachments/assets/b1e0dd07-dd3b-4daf-8d5f-034e17d4e51f)
也是经典题 使用动态规划 就从第1个元素开始 下一格元素 大于0就加 小于0就判断如果加上这个数比0还小 就都不选 如果减掉之后比0大 就选 知道第i个
```python
class solution:
    def __init__(self,n,num):
        self.n=n
        self.num=num
        self.max=-10000
        self.dp=[0 for _ in range(n)]
    def dps(self):
        self.dp[0]=self.num[0]
        for i in range(1,self.n):
            if self.num[i]>=0:
                self.dp[i]=self.dp[i-1]+self.num[i]
            else:
                self.dp[i]=max(0,self.dp[i-1]+self.num[i])
            if self.dp[i]>self.max:
                self.max=self.dp[i]
        if max(self.num)<=0:
            return max(self.num)
        return self.max
n=int(input())
num=list(map(int,input().split(" ")))
solution=solution(n,num)
print(solution.dps())
```





# 回溯法 
回溯法是一种主要通过递归的方式完成的算法 通过暴力搜索（无法通过循环得到的情况） 区别就在会在遇到不可行的时候进行回溯 重新寻找出路

要理解并不难 难就难在如何写逻辑

例子 【1，2，3，4】
找到所有长度为二的子集
也就是【1，2】【1，3】【1，4】...
那么在递归时 找到【1，2】之后 就需要回溯 退回【1】 才能继续寻找下一格【1，3】
在代码的实现上 前半部分都跟递归的实现一致
**重点区别**
需要在结尾使用path.pop()
也就是回溯 从而使得进入下一个分支
 # 分治法
 1. 一个问题能缩减到足够小的规模就能够解决
 2. 可以分解成若干个较小的相同问题
 3. 可以合并
 4. 相互独立（没有重叠包含）
思路就是逐步减小问题 知道足够简单 就返回处理 向上更新
![image](https://github.com/user-attachments/assets/a9e31ade-f932-4c23-bfd5-1a77bff5c4e2)

要求是
1. 每行一个
2. 每列一个
3. 没对角线一个
那我们就从行入手 循环每行 然后找到一行中可以填的位置 然后递归到下一行
```python
class solution:
    def __init__(self,n):
        self.dp=[[0 for _ in range(n)] for _ in range(n)]
        self.n=n
        self.solution_all=[]
        self.length=0
    def is_put(self,row,col):
        for i in range(self.n):
            if self.dp[i][col]==1:
                return False//每列判断
        i,j=row-1,col-1
        while i>=0 and j>=0:
            if self.dp[i][j]==1://对角线判断 只需要判断在row上方的就可以
                return False
            i-=1
            j-=1
        i,j=row-1,col+1
        while i>=0 and j<self.n:
            if self.dp[i][j]==1:
                return False
            i-=1
            j+=1
        return True
    

    def backtrack(self,row):
        if row==self.n:
            solution_list=[]
            for i in range(self.n):
                for j in range(self.n):
                    if self.dp[i][j]==1:
                        solution_list.append(j+1)
            self.solution_all.append(solution_list)
            self.length+=1
            return
        for col in range(self.n):
            if self.is_put(row,col):
                self.dp[row][col]=1
                self.backtrack(row+1)a
                self.dp[row][col]=0//在完成了这一行所造成的所以结果后 撤销这一次的选择 选择下一列 以保证遍历所有情况
    def printf(self):
        for i in range(3):
            for j in self.solution_all[i]:
                print(j,end=" ")
            print()
        print(self.length)
n=int(input())
solution=solution(n)
solution.backtrack(0)
solution.printf()

            
```
![image](https://github.com/user-attachments/assets/d195a82d-2f99-475d-9913-059f6a411ddd)
这题使用回溯法的思路就是 从每行开始 遍历每行 通过判断这个数是否可取 不可取就下一个 可取就吧这个标记 然后加上这个数 然后下一个 再回溯
 回溯时要把加上的数再减掉
 ```python
class Solution:
    def __init__(self, n, m, num_list):
        self.num_list = num_list
        self.n, self.m = n, m
        self.visited = [[False] * m for _ in range(n)]  # 访问标记
        self.max_sum = 0  # 记录最大值
        self.temp_sum = 0  # 记录当前选择的总和

    def is_safe(self, row, col):
        """检查 (row, col) 是否可以选取"""
        directions = [(-1, -1), (-1, 0), (-1, 1),
                      (0, -1), (0, 1),
                      (1, -1), (1, 0), (1, 1)]  # 8个方向
        for dr, dc in directions:
            nr, nc = row + dr, col + dc
            if 0 <= nr < self.n and 0 <= nc < self.m and self.visited[nr][nc]://这是一个重要步骤 不必把选了的点周围全部标记 只需要判断当前点的四周有无出现以标记的点就行
                return False  # 如果相邻格子已被选取，则不可选
        return True

    def backtrack(self, row, col):
        """回溯搜索最大不相邻和"""
        if row == self.n:  # 遍历完所有行
            self.max_sum = max(self.max_sum, self.temp_sum)
            return

        next_row, next_col = (row, col + 1) if col + 1 < self.m else (row + 1, 0)

        # 不选当前格子，直接跳到下一个格子
        self.backtrack(next_row, next_col)

        # 选择当前格子（如果安全）
        if self.is_safe(row, col):
            self.visited[row][col] = True
            self.temp_sum += self.num_list[row][col]

            self.backtrack(next_row, next_col)  # 递归

            # 撤销选择（回溯）
            self.visited[row][col] = False
            self.temp_sum -= self.num_list[row][col]

    def get_max_sum(self):
        self.backtrack(0, 0)
        return self.max_sum


# 处理输入
T = int(input())  # 读取测试用例的数量

for _ in range(T):
    N, M = map(int, input().split())  # 读取矩阵的行数和列数
    matrix = [list(map(int, input().split())) for _ in range(N)]  # 读取矩阵
    solution = Solution(N, M, matrix)
    print(solution.get_max_sum())  # 输出结果
```


# 双指针
双指针算不上是一种算法 不过是一种算法技巧 一般用于解决数组 链表的查找问题

![image](https://github.com/user-attachments/assets/a1e85934-9d88-4e9b-88a3-eb94c0dc252d)
如果忽略字符串的删除 这题就可以正常使用双指针解决 
终止条件是i>=j
但是在这题中  可以使用贪心的想法  
```python
class Solution:
    def validPalindrome(self, s: str) -> bool:
        def check(i,j):
        
            while i<j:
                if s[i]!=s[j]:
                    return False
                i+=1
                j-=1
            return True
        i,j=0,len(s)-1
        while i<j:
            if s[i]!=s[j]:
                return check(i,j-1) or check(i+1,j)
            i+=1
            j-=1
        return True
```
思路就是 如果在指针的移动中 首次出现了不是互文的时候 对首指针和末指针分别减一 只要有一个能成就行

#递归 
这个不用讲 函数套函数 从头开始
![image](https://github.com/user-attachments/assets/74d5c8e8-9731-42cb-a2be-a4d3e0caa461)
这题的思路就是 不断找到最大的2的幂 然后对剩下的数以及幂进行递归 具体看代码
```python
class solution:
    def max_find(self,num):
        i=0
        while num-2**(i+1)>=0:
            i+=1
        return i
    def printf(self,num):
        if num==1:
            return "2(0)"
        elif num==2:
            return "2"
        # elif num==4:
        #     return "2(2)"
        max_ex=self.max_find(num)
        remain=num-2**max_ex
        # if max_ex==1:
        #     max_ex = "2"
        # if max_ex==0:
        #     max_ex= "2(0)"
        # if max_ex==4:
        #     max_ex= "2(2)"
        
        
        if remain==0:
            if max_ex==1:
                return "2"
            else:
                return f"2({self.printf(max_ex)})"
            
        else:
            if max_ex==1:
                return f"2+{self.printf(remain)}"
            else:
                return f"2({self.printf(max_ex)})+{self.printf(remain)}"
num=int(input())
solute=solution()
print(solute.printf(num))

```
# 异或 
基本原理是 在二进制中 1^1=0 1^0=1 并且满足交换律

### 例子 查找一段数据【1，2，5，7，2，1，7】中只出现一次的数据
```python
nums=【1，2，5，7，2，1，7】
res=0
for num in nums:
	res^=num
print(res)
```
过程大概就是 0^1^2^5^7^2^1^7

又因为相同的异或值为0 0异或任何数都是任何数 因此得到单独的数

查找一连串数字中缺失的数字
```python
def missingNumber(nums):
    n = len(nums)
    res = n  # 因为索引从 0 到 n-1，我们先加上 n
    for i in range(n):
        res ^= i ^ nums[i]
    return res
```
### 异或和
1^2^3^4^5就是异或和 类似与1+2+3+4+5






