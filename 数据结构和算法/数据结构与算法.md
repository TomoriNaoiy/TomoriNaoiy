数据结构和算法
===
由于对python比较熟悉 这里使用python为主进行学习

# 栈
原理就是 后进先出 也就是一个无盖的盒子 从上到下堆放 放进去的再最上面 取出的时候也是拿最上面

操作
### 进栈push
### 出栈pop
### 取栈顶gettop（也就是list[-1]）
```python
Class stack:
  def __init__(self):
    self.stack=[]
  def push(self,element):
    self.stack.append(element)
  def pop(self):
    return self.stack.pop()
  def get_top(self):
    if(len(self.stack))>0:
      return self.stack[-1]
    else:
      return None
```
# 栈的实践----深度优先搜索
这里以迷宫举例 在一个9*9的迷宫中 找到一条出路

以深度优先搜索的思路 便是一条路一直走（1上2右3上4左） 知道4个方向均无路（已走） 便出栈 到上一步继续寻找其他方向 如果继续无路 就再出栈 知道走到出口
```python
maze=   [[1,1,1,1,1,1,1,1,1,1],
		[1,0,0,1,0,0,0,1,0,1],
		[1,0,0,1,0,0,0,1,0,1],
		[1,0,0,0,0,1,1,0,0,1],
		[1,0,1,1,1,0,0,0,0,1],
		[1,0,0,0,1,0,0,0,0,1],
		[1,0,1,0,0,0,1,0,0,1],
		[1,0,1,1,1,0,1,1,0,1],
		[1,1,0,0,0,0,0,0,0,1],
		[1,1,1,1,1,1,1,1,1,1]]
dirs=[lambda x,y:(x+1,y),
    lambda x,y:(x,y+1),
    lambda x,y:(x-1,y),
    lambda x,y:(x,y-1)]
def printmaze(maze,dirs):
    stack=[]
    stack.append((1,1))
    while len(stack)>0:
        curNode=stack[-1]
        if curNode==(8,8):
            print("byd你的路走到头了")
            for p in stack:
                print(p)
            return True
        for dir in dirs:
            nextNode=dir(curNode[0],curNode[1])
            if maze[nextNode[0]][nextNode[1]]==0:
                stack.append(nextNode)
                maze[nextNode[0]][nextNode[1]]=2
                break
        else:
            maze[nextNode[0]][nextNode[1]]=2
            stack.pop()
    else:
        print("byd没有路了")
        return False
printmaze(maze,dirs)
```
![image](https://github.com/user-attachments/assets/2a3cc382-302a-466e-a067-6021be488075)
经典题目 根据深度优先搜索 先进行遍历 每次遇到1 就进行一次dfs 并将周围所有的1变成0 （或者2） 然后继续往下遍历 每次遇到1就岛屿数就加一 然后开始dfs
```python
class Solution:
    def dfs(self,grid,r,c):
            grid[r][c]=0
            l,w=len(grid),len(grid[0])
            for x,y in [(r-1,c),(r+1,c),(r,c+1),(r,c-1)]:
                if 0<=x<l and 0<=y<w and grid[x][y]=="1":
                    self.dfs(grid,x,y)
        
    def numIslands(self, grid: List[List[str]]) -> int:
         l,w=len(grid),len(grid[0])
         ans=0
         for r in range(l):
            for c in range(w):
                if grid[r][c]=="1":
                    ans+=1
                    self.dfs(grid,r,c)
         return ans
 ```
# 队列
原理就是 先进先出 也就是一个单向通道 一边只能进 一边只能出

因为如果正常列表 会出现空间被占用 效率不高

因此我们多用环线队列
```python
#front 队首
#rear 队尾
```
### 队首指针前进 front = （front+1）%maxsize
### 队尾rear = （rear+1）%maxsize
### 队空 rear==front
### 队满（rear+1）%maxsize==front

```python
Class Queue:
  def __init__(self,size=100):
    self.queue=[0 for _ in range(size)]
    self.size=size
    self.rear=0
    self.front=0
  def push(self,element):
    if not is_filled():
      self.rear=(self.rear+1)%self.size
      self.queue[self.rear]=element
    else:
      ()=()
  def pop(self):
    if is_empty():
      self.front=(self.front+1)%self.size
      return self.queue[self.front]
    else:
      ()=()
  def is_empty(self):
    return self.rear==self.front
  def is_filled(self)
    return (self.rear+1)%self.size==self.front
```
# 更简单的实现
当然就是独属于我们pythoner的方法 调用了
```python
from collections import deque
q=deque()
a.append()
q.popleft()
```
### 迷宫实现 队列--广度优先搜索
```python
from collections import deque
maze= [[1,1,1,1,1,1,1,1,1,1],
		[1,0,0,1,0,0,0,1,0,1],
		[1,0,0,1,0,0,0,1,0,1],
		[1,0,0,0,0,1,1,0,0,1],
		[1,0,1,1,1,0,0,0,0,1],
		[1,0,0,0,1,0,0,0,0,1],
		[1,0,1,0,0,0,1,0,0,1],
		[1,0,1,1,1,0,1,1,0,1],
		[1,1,0,0,0,0,0,0,0,1],
		[1,1,1,1,1,1,1,1,1,1]]
dirs=[lambda x,y:(x+1,y),
    lambda x,y:(x,y+1),
    lambda x,y:(x-1,y),
    lambda x,y:(x,y-1)]
def path_print(path):
	curNode=path[-1]
	real_path=[]
	while curNode[2]!=-1:
		real_path.append(curNode[0:2])
		curNode=path[curNode[2]]
	real_path.append(curNode[0:2])
	
	for i in reversed(real_path):
		print(i)
def path_find(x1,y1):
	quque=deque()
	path=[]
	quque.append((x1,y1,-1))
	while len(quque)>0:
		curNode=quque.popleft()
		path.append(curNode)
		if curNode[0:2]==(8,8):
			print("到了")
			path_print(path)
			return True			
		for dir in dirs:
			nextNode=dir(curNode[0],curNode[1])
			if maze[nextNode[0]][nextNode[1]]==0:
				quque.append((nextNode[0],nextNode[1],len(path)-1))
				maze[nextNode[0]][nextNode[1]]=2
	else:
		print("无路可走")
path_find(1,1)
```
相对于栈的优势 队列在求此类问题上 最大的优势是能获得**最短路径**

# 链表
一个彼此相连的线性结构

链表的每个单位包含两个部分 内容部分和指针部分

在py中 每个节点也就是一个对象
```python
 class node:
     def __init__(self,value):
         self.value=value
         self.next=None
 class line:
     def __init__(self):
         self.head=None
     def creat(self,value):
         newnode=node(value)
         if not self.head:
             self.head=newnode
             return
         cur=self.head
         while cur.next:
             cur=cur.next
         cur.next=newnode
     def printf(self):
         cur=self.head
       while cur is not None:
             print(cur.value,end=" ")
             cur=cur.next
     def link(self,value,position):
         cur=self.head
         new=node(value)
         if position == 0:
            new.next=self.head
             self.head=new
             return
         cur=self.head
         for _ in range(position-1):
             cur=cur.next
         new.next=cur.next
         cur.next=new
     def delete(self,value):
         cur=self.head
         while cur.next.value!=value:
             cur=cur.next
         cur.next=cur.next.next
        
```
# 哈希表
哈希表实际就是一个带有哈希函数的链表集

由于正常的集合 列表 需要纯的位数多 可能会需要开一个巨大的空间 但是许多位置是空出来的 占用了内存 因此诞生哈希表 

哈希表将下标使用h（x）处理 也就是说列表中 下标是k 哈希表中 下标就是h（k）

常用的哈希函数之一 k%size

也就是开一个大小为7的链表集 

**为何要开链表？**
因为如果开k%size 这个哈希表每个位置只能放入一个 那么同时出现两个相同的位置的数就会出现哈希冲突例如 0 和size最后得到的下标都是0 那么久使用链表 将哈希冲突的值连在一起
# 定义链表节点类
```python
class ListNode:
    def __init__(self, key, value):
        self.key = key
        self.value = value
        self.next = None

# 定义哈希表类
class HashTable:
    def __init__(self, size):
        # 初始化哈希表的大小和存储列表
        self.size = size
        # 每个位置初始化为 None，表示还没有元素
        self.table = [None] * size

    def _hash(self, key):
        # 哈希函数，将键转换为索引
        return hash(key) % self.size

    def put(self, key, value):
        # 计算键对应的哈希索引
        index = self._hash(key)
        # 获取该索引位置的链表头节点
        head = self.table[index]
        current = head
        # 遍历链表，查找是否已存在该键
        while current:
            if current.key == key:
                # 如果键已存在，更新值
                current.value = value
                return
            current = current.next
        # 如果键不存在，创建新节点并插入到链表头部
        new_node = ListNode(key, value)
        new_node.next = head
        self.table[index] = new_node

    def get(self, key):
        # 计算键对应的哈希索引
        index = self._hash(key)
        # 获取该索引位置的链表头节点
        head = self.table[index]
        current = head
        # 遍历链表，查找该键
        while current:
            if current.key == key:
                return current.value
            current = current.next
        # 如果键不存在，返回 None
        return None

    def remove(self, key):
        # 计算键对应的哈希索引
        index = self._hash(key)
        # 获取该索引位置的链表头节点
        head = self.table[index]
        prev = None
        current = head
        # 遍历链表，查找该键
        while current:
            if current.key == key:
                if prev:
                    # 如果不是头节点，将前一个节点的 next 指向当前节点的下一个节点
                    prev.next = current.next
                else:
                    # 如果是头节点，更新头节点为当前节点的下一个节点
                    self.table[index] = current.next
                return
            prev = current
            current = current.next

# 使用自定义哈希表
hash_table = HashTable(10)
hash_table.put('apple', 1)
hash_table.put('banana', 2)
print(hash_table.get('apple'))  # 输出: 1
hash_table.remove('banana')
print(hash_table.get('banana'))  # 输出: None
```\
# 树
一个可以由递归定义的数据结构
```python
class Node:
	def __init__(self,name,dir):
		self.name=name
		self.dir=dir
		self.children=[]
		self.parent=None
node=Node()
node2=Node()
node.name="1"
node2.name="2"
node.children.append(node2)
node2.parent=node
```
## 二叉树
也就是只有至多两个子节点的数
```python
class BitreeNode:
	def __init__(self,data):
		self.data=data
		self.rchildren=None
		self.lchildren=None
```
分为左节点和右节点

### 遍历二叉树
递归遍历
```python
def print_tree(root):
	if root:
		print(root.data)
		print_tree(root.lchildren)
		prnt_tree(root.rchildren)

### 二叉搜索树
所有父节点都大于左子节点 右子节点大于父节点的二叉树


```python
class BitreeNode:
	def __init__(self,data):
		self.data=data
		self.rchildren=None
		self.lchildren=None
class BST:
 	def __init__(self):
		self.root=None
	def insert(self,node,val):
		if not node:
			node=BitreeNode(val)
		elif val<node.data:
			node.lchild=self.insert(node.lchild,val)
		elif val>=node.data:
			node.rchild=self.insert(node.rchild,val)
	return node

#插入
def query(self,node,val):
	if not node:
		return None
	if node.data<val:
		return self.query(node.rchild,val)
	elif node.data>val:
		return self.quert(node.lchild,val)
	else:
		return 	node
```
**删除**
1.单子叶 直接删除

2.有一个孩子的父结点 将这个节点的孩子和父亲相连

3.两个汉字 找右子树的最小节点替换该结点 并删除该节点
```python
def remove_node1(self,node):
	if nodt node.parent:
		self.root=None
	if node == node.parent.lchild#父亲的什么孩子
		node.parent.lchild=None
		node.parent=None
	#else
	return node
def remove_node2(self,node):
	if  not node.parent:
		self.root=node.lchild
		node.lchild.parent=None
	elif node==node.parent.lchild:
		node.parent.lchild=node.lchild
		node.lchild.parent=node.parent
	else:
	return node
def remove_node3(self,node):
	min_node=node.rchild:
	while min_node.lchild:
		min_node=min_node.lchild
	node.data=min_node.data
	#然后用1的方法 删掉这个子节点
```
### 二叉树的遍历
![image](https://github.com/user-attachments/assets/648c01a2-0baf-4d5e-a6be-6c1c786299f7)
如果你按照 根节点 -> 左孩子 -> 右孩子 的方式遍历，即「先序遍历」，每次先遍历根节点，遍历结果为 1 2 4 5 3 6 7；

同理，如果你按照 左孩子 -> 根节点 -> 右孩子 的方式遍历，即「中序序遍历」，遍历结果为 4 2 5 1 6 3 7；

如果你按照 左孩子 -> 右孩子 -> 根节点 的方式遍历，即「后序序遍历」，遍历结果为 4 5 2 6 7 3 1；

最后，层次遍历就是按照每一层从左向右的方式进行遍历，遍历结果为 1 2 3 4 5 6 7。


```python
#前序
def dfs(root):
	if not root:
		return
	print(root.value)
	dfs(root.lchildren)
	dfs(root.rchildren)
#中序
只要改变位置即可
def dfs(root):
	if not root:
		return
	dfs(root.lchildren)
	print(root.value)
	dfs(root.rchildren)
#同样 后序 只需要
	dfs(root.l)
	dfs(root.r)
	print()
```
	
		




算法
========
# 贪心算法 
远近闻名的算法

开始前 先想想 我们为什么要使用算法 

正常来说 以人的思路来做 很可能将一个问题复杂化 又或者是使用的思路会具有很大的复杂度 而使用算法能大大的帮我门提高程序效率和降低占用资源

**那么开始**
贪心算法的基本思路就是 选取每个部分的局部最优解（也就是不从整体上来考虑 而是对部分求最优解）从而使得所有的局部最优解合成一个整体最优解 但是这样的结果有时不会是最优的 因此贪心不一定在所有场景都有效果 而贪心算法的特点是不会对以及做过选择的部分进行回溯思考
### 贪心的步骤
1. 确定问题的优化目标：明确需要最大化或最小化的目标。
2. 确定贪心策略：定义每一步的局部最优选择。
3. 证明贪心策略的正确性：确保贪心选择能够导致全局最优解。
4. 实现算法：根据贪心策略编写代码。
5. 验证结果：检查算法是否得到了正确的结果。

通过一个经典的例子举例 要购买股票并获得最大的受益 
七天内的股值为[7,1,5,3,6,4,2]
那么贪心的思路就是 **如果今天买明天卖就有受益 那就今天买** 这就是局部的最优
```python
gp=[7,1,5,3,6,4]
profit=0
for i in range(len(gp)):
	if gp[i]<gp[i+1]:
		profit+=gp[i+1]-gp[i]
```
接下来是喂小孩子的例子
【1，2，3】这是有的饼干
【1，2】这是小孩的饱食度
要喂饱尽可能多的小孩 

贪心算法的思路就是 从最好饱的开始 那就是1喂1 2喂2
```python
children=[1,2]
cookies=[1,2]
child=0
cookie=0
while(child<len(chileren) and cookie<len(cookies)):
	if children[child]<=cookies[cookie]:
		child+=1
	cookie+=1
```
第三个例子 
去掉部分区间 使得所有区间没有重合
【1,2】,[1,3],[2,4]
我们的做法是 先**排序**（很重要的步骤 几乎所有都要贪心排序） 然后根据保留结尾最小的区间 并且与前面的区间没有重合的部分
![image](https://github.com/user-attachments/assets/1219a12f-53a1-4494-bb8f-2a73fe0dbdd2)
这一题 贪心算法就是**能种便种**
```python
class Solution:
    def canPlaceFlowers(self, flowerbed: List[int], n: int) -> bool:
        flowerbed=[0]+flowerbed+[0] #本实现最大亮点 由于底下的做法可能回忽略掉两边墙壁（只要有一边为1）因此我们可以在原列表的两边加上0  将墙壁模拟成正常的部分比如[0,0,1,1,0]
        for i in range(1,len(flowerbed)-1):
           
            
            if flowerbed[i]!=1 and flowerbed[i+1]!=1 and flowerbed[i-1]!=1:
                flowerbed[i]=1
                n-=1
      
        return n<=0

```



# 动态规划
又是一个及其重要的算法 以我的理解 核心就是
1. 找到状态转移方程 人话来说 就是当前节点的结果必须根据前一次或若干次结果得到
2. 存储中间结果 也就是俗话说的记忆化搜索 为了避免重复计算 将计算结果存储 然后每次检查 若有就直接返回 没有就计算后存入
再讲的通俗一点 就是逐步减小问题的规模 例如求f（n） 就缩减为跟f（n-1）的关系 然后以此类推 知道得到结果

理论结束 实践开始
nums=[1,5,2,4,3]
找出最长的递增的子数列

正常想法 ：暴力
也就是使用嵌套循环 
![image](https://github.com/user-attachments/assets/93624830-bfeb-4b59-a78a-882e52fb8b62)
通过遍历每个树 再获得最长
```python
def L(num,i):
	if i==len(num)-1:
		return 1
	#遍历倒末尾的时候停止
	max_len=1
	for j in range(i+1,len(nums)):
		if num[j]>num[i]:
			max_len=max(max_len,L(nums,j)+1)
	return max_len
```
这里就是用递归的想法完成的实现（其实已经有部分动态规划的想法在里面了）
动态规划的做法
```
memo={}

def L(num,i):
	if i in memo:
		return memo[i]
	if i==len(num)-1:
		return 1
	#遍历倒末尾的时候停止
	max_len=1
	for j in range(i+1,len(nums)):
		if num[j]>num[i]:
			max_len=max(max_len,L(nums,j)+1)
	memo[i]=max_lem
	return max_len
```
很明显 这里相对于递归的做法 我们加入了记忆化搜索 这样子将效率大大提高

那么不使用递归呢 

![image](https://github.com/user-attachments/assets/84f03a19-0b34-4d17-9229-f6178b14cb2b)
便是如此 这样就是完成的动态规划的算法 通过类似数学归纳法的方法 通过对逐渐减小的规模使用相同的函数返回 知道得到最终结果
```python
def length_of_LIS(nums):
	n=len(nums)
	L=[1 for _ in range(5)]
	for i in reversed(range(n)):
		for j in range(i+1,n):
			if nums[j]>nums[i]:
				L[i]=max(L[i],L[j]+1)
	return max(L)
```
![image](https://github.com/user-attachments/assets/3c0b34a3-15d2-42df-93ac-b8cc67a11e3f)
最最简单且经典的动态规划
```python
class solution:
    def jc(self,num):
        if num==1:
            return 1
        return num*self.jc(num-1)
    def s(self,val):
        if val==1:
            return 1
        return self.jc(val)+self.s(val-1)
so=solution()
n=int(input())
print(so.s(n))
```

![image](https://github.com/user-attachments/assets/4b04e849-b5aa-4cbe-9ac1-c2c82170632e)
这题使用动态规划 要找到最小值 只需要在每一步取min即可
```python
class Solution:
    def minCostClimbingStairs(self, cost: List[int]) -> int:
        n=len(cost)
        dp=[0]*(n+1)
        for i in range(2,n+1):
            dp[i]=min(dp[i-1]+cost[i-1],dp[i-2]+cost[i-2])
        return dp[n]
```
![image](https://github.com/user-attachments/assets/5ee4793d-663a-4235-af59-1b2cac642338)
这一题使用两层线性动态规划 一层时间 一层空间 

由于球只能来自于左边或右边 

方程为dp[i][j]=dp[i-1][j-1]+dp[i-1][j+1]

```python
class Solution:
    def where(self, n, m):
        # 初始化 dp 数组
        dp = [[0] * n for _ in range(m + 1)]
        dp[0][0] = 1  # 初始时，球在小蛮手里

        # 动态规划计算
        for i in range(1, m + 1):
            for j in range(n):
                # 球可以从左边或右边的同学传过来
                dp[i][j] = dp[i - 1][(j - 1 + n) % n] + dp[i - 1][(j + 1) % n]

        # 返回球传了 m 次后回到小蛮手里的方法数
        return dp[m][0]

# 测试
s = Solution()
print(s.where(3, 3))  # 输出 2
```
![image](https://github.com/user-attachments/assets/06bf40b0-d786-4a5c-9048-e165df2c23ba)
这题想法是

dp[j] 表示在时间 j 内可以采到的草药的最大总价值。

初始化时，dp 数组的所有值都为 0，因为初始时没有采任何草药。

遍历草药：



对于每一种草药，更新 dp 数组。

从后往前更新是为了避免重复计算（即保证每种草药只能选一次）。

状态转移方程：

dp[j] = max(dp[j], dp[j - 时间] + 价值)：选择采或不采当前草药，取最大值。
```python
def max_herb_value(total_time, num_herbs, herbs):
    dp = [0] * (total_time + 1)  # dp[i] represents the maximum value for time i
    for time, value in herbs:
        for t in range(total_time, time - 1, -1):
            dp[t] = max(dp[t], dp[t - time] + value)
    return dp[total_time]

# Input
T, M = map(int, input().split())
herbs = []
for _ in range(M):
    time, value = map(int, input().split())
    herbs.append((time, value))

# Output
print(max_herb_value(T, M, herbs))
```
可以看到，容量大的时候的值取决于容量小的时候的值，从而不断被正确更新，所以用一维 dp 的时候，j 的循环必须是从大到小逆序开始的，逆序，就防止了一个物品放入多次！！！否则...........
dp[i][j]=max(dp[i−1][j−w[i]])+v[i],dp[i−1][j])这是二维的方程 为了减小空间 我们去掉i 只使用一维
![image](https://github.com/user-attachments/assets/e46e3ac1-bcd9-44bd-b521-05b5f329bee4)
经典题 思路蛮简单 就是一个点从前面两个位置来 使用递归
```python
class solution:
    def __init__(self,x0,y0,x1,y1):
        self.x0=x0
        self.y0=y0
        self.dp=[[-1 for _ in  range(y0+1)] for _ in range(x0+1)]# 这里注意 大小假如6 6 那么我们要多开一格 方便我们后面使用【6】【6】
        for dx, dy in [(-2, -1), (-1, -2), (1, -2), (2, -1), (2, 1), (1, 2), (-1, 2), (-2, 1),(0,0)]:
            nx, ny = x1 + dx, y1 + dy
            if 0 <= nx <= x0 and 0 <= ny <= y0:
                self.dp[nx][ny] = 0  
        
    def path(self,x,y):
        
        if x==0 and y==0:
            return 1//到起点 返回1
        if x<0 or y<0:
            return 0 //超过边界或者被拦住 就返回0
        if self.dp[x][y]==0 :
            return 0
        if self.dp[x][y]!=-1: 如果以及计算过 就直接返回 
            return self.dp[x][y]
        
        self.dp[x][y]=self.path(x-1,y)+self.path(x,y-1)
        return self.dp[x][y]
        
z=list(map(int,input().split()))
x0,y0,x1,y1=z[0],z[1],z[2],z[3]
solution=solution(x0,y0,x1,y1)
print(solution.path(x0,y0))
```


# 回溯法 
回溯法是一种主要通过递归的方式完成的算法 通过暴力搜索（无法通过循环得到的情况） 区别就在会在遇到不可行的时候进行回溯 重新寻找出路

要理解并不难 难就难在如何写逻辑

例子 【1，2，3，4】
找到所有长度为二的子集
也就是【1，2】【1，3】【1，4】...
那么在递归时 找到【1，2】之后 就需要回溯 退回【1】 才能继续寻找下一格【1，3】
在代码的实现上 前半部分都跟递归的实现一致
**重点区别**
需要在结尾使用path.pop()
也就是回溯 从而使得进入下一个分支
 # 分治法
 1. 一个问题能缩减到足够小的规模就能够解决
 2. 可以分解成若干个较小的相同问题
 3. 可以合并
 4. 相互独立（没有重叠包含）
思路就是逐步减小问题 知道足够简单 就返回处理 向上更新
# 双指针
双指针算不上是一种算法 不过是一种算法技巧 一般用于解决数组 链表的查找问题

![image](https://github.com/user-attachments/assets/a1e85934-9d88-4e9b-88a3-eb94c0dc252d)
如果忽略字符串的删除 这题就可以正常使用双指针解决 
终止条件是i>=j
但是在这题中  可以使用贪心的想法  
```python
class Solution:
    def validPalindrome(self, s: str) -> bool:
        def check(i,j):
        
            while i<j:
                if s[i]!=s[j]:
                    return False
                i+=1
                j-=1
            return True
        i,j=0,len(s)-1
        while i<j:
            if s[i]!=s[j]:
                return check(i,j-1) or check(i+1,j)
            i+=1
            j-=1
        return True
```
思路就是 如果在指针的移动中 首次出现了不是互文的时候 对首指针和末指针分别减一 只要有一个能成就行

#递归 
这个不用讲 函数套函数 从头开始
![image](https://github.com/user-attachments/assets/74d5c8e8-9731-42cb-a2be-a4d3e0caa461)
这题的思路就是 不断找到最大的2的幂 然后对剩下的数以及幂进行递归 具体看代码
```python
class solution:
    def max_find(self,num):
        i=0
        while num-2**(i+1)>=0:
            i+=1
        return i
    def printf(self,num):
        if num==1:
            return "2(0)"
        elif num==2:
            return "2"
        # elif num==4:
        #     return "2(2)"
        max_ex=self.max_find(num)
        remain=num-2**max_ex
        # if max_ex==1:
        #     max_ex = "2"
        # if max_ex==0:
        #     max_ex= "2(0)"
        # if max_ex==4:
        #     max_ex= "2(2)"
        
        
        if remain==0:
            if max_ex==1:
                return "2"
            else:
                return f"2({self.printf(max_ex)})"
            
        else:
            if max_ex==1:
                return f"2+{self.printf(remain)}"
            else:
                return f"2({self.printf(max_ex)})+{self.printf(remain)}"
num=int(input())
solute=solution()
print(solute.printf(num))

```



