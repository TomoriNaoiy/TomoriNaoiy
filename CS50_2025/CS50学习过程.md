开始CS50的学习 从51开始 希望能在两个月内完成
=======================

#week1 C语言的入门

VSC编译器 究竟是在作什么？
实际上 我们使用code a.c 创建一个c语言的文件 然后通过make hello 将其转化为机器代码 然后再通过./hello 运行这段机器代码（由于是机器代码 我们无法看到 就算打开也只是乱码）

一些转义符的用法\n \r(光标移至行首而非下一行) \" \\ \' 可以打出实际的 “ ‘ \

几个命令
- cd 打开某个文件夹 文件
- cp 复制
- mkdir创建文件夹 类似mkdir a
- rm 删除 rm a 后面会询问你是否确认 输入y即可
- mv 移动 比如 mv hhh a 把hhh移到a文件夹里面

task mario
简单来说 就是做一个右对齐的金字塔 其实里面的创新点在于 输入一个数 如果不是符合 就再次重复 用到do while语句
do
{
int h;
cin>>h;

}
while(h<=0 or h>9);

# week2 array
这节课没啥内容 主要是一个 int main（）里面是可以传参数的 
int main（int arg）
这个时候在运行时就可以给予参数

加入文件为greet 则cmd里面输入./greet 10 就可以直接给参数了 一般来说时void

# week3 算法 
题目虽然是算法 但是实际上基本涉及很少 主要讲了三种排序 
1. 冒泡 懂的都懂 面对以及排序好的列表会很快 其他一般
2. 选择 都差不多
3. 归并 相对于前两个会快 毕竟是logn复杂度 通过递归 类似于二分 将43|16二分部 然后判断是否是单个数字 不是就继续分 然后对4 3排序 变成3 4 然后对16 变成1 6 最后根据3 和1 的大小分在第一和第二位

然后就是一些很简单的数组题目 不涉及什么算法 值得说的就是c语言里面只能strmp（） 不能== 有点蠢

# week4 记忆

先是提到指针 说到内存是根据16进制计算的 

%p，它允许我们查看内存中某个位置的地址。&n可以直译为“的地址n”。执行此代码将返回以 开头的内存地址0x。
```c
// Prints an integer's address

#include <stdio.h>

int main(void)
{
    int n = 50;
    printf("%p\n", &n);
}
```

指针是一个存储某个对象地址的变量。简而言之，指针就是计算机内存中的一个地址。
![image](https://github.com/user-attachments/assets/1e6d0758-1ded-4906-b523-b9defcac3e44)

总之 char *s=“HI！” s便是指向H的地址
```c
// Declares a string without CS50 Library

#include <stdio.h>

int main(void)
{
    char *s = "HI!";
    printf("%s\n", s);
}
```

因此在这里字符指针和字符数组有很大的相同点 但也有所区别
s[]="hi" 创建了一个大小由字符串长度决定的空间 

*s=“hi” 则是一个指向字符串的首地址的指针  并且只读 也就是说你无法通过s[0]=“1”改变 但是数组就可以

空间上来说 s[]是创建了一个新开辟的空间中 而指针则是在一个常量区

用法上 都可以使用s[0]下标进行获得元素
```c
/ Prints a string's chars via pointer arithmetic

#include <stdio.h>

int main(void)
{
    char *s = "HI!";
    printf("%c\n", *s);
    printf("%c\n", *(s + 1));
    printf("%c\n", *(s + 2));
}
```
因此在毕竟两个字符串时 ==比较的是两个字符串的地址 需要使用strmp

那么malloc和free有何用呢 

在我们需要复制一个字符串的时候 例如*s="666"；

那我们若要复制 就要开辟一个空间（不是数组） char *t=malloc(strlen(s)+1)

也就是说 在创造一个不止长度的s时 char*s=malloc（4） 和s[4]等价
当然我们有strcp(

```c
// Demonstrates memory errors via valgrind

#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    int *x = malloc(3 * sizeof(int));
    x[1] = 72;
    x[2] = 73;
    x[3] = 33;
    free(x);
}
```
为什么我们要是有sizeof（int）呢 其实直接写3就行 sizeof（int）获得一个int所占的字节 这行代码就是打开3歌int字节 这样写更方便看..

```c++
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    int scores[1024];
    for (int i = 0; i < 1024; i++)
    {
        printf("%i\n", scores[i]);
    }
}
```
这里如果运行 可能会出现一些逆天数值 那就是因为开辟的空间可能以及被占用 你又没有给新的值 因此出现奇奇怪怪的值

题目 第一题写了一个音频处理 主要是一些文件处理的格式 代码贴出来
```c
// Modifies the volume of an audio file

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// Number of bytes in .wav header
const int HEADER_SIZE = 44;

int main(int argc, char *argv[])
{
    // Check command-line arguments
    if (argc != 4)
    {
        printf("Usage: ./volume input.wav output.wav factor\n");
        return 1;
    }

    // Open files and determine scaling factor
    FILE *input = fopen(argv[1], "r");
    if (input == NULL)
    {
        printf("Could not open file.\n");
        return 1;
    }

    FILE *output = fopen(argv[2], "w");
    if (output == NULL)
    {
        printf("Could not open file.\n");
        return 1;
    }

    float factor = atof(argv[3]);

    // TODO: Copy header from input file to output file
    uint8_t header[HEADER_SIZE];
    fread(header, HEADER_SIZE, 1, input);
    fwrite(header, HEADER_SIZE, 1, output);
    // TODO: Read samples from input file and write updated data to output file
    int16_t buffer;

// Read single sample from input into buffer while there are samples left to read
    while (fread(&buffer, sizeof(int16_t), 1, input))
    {

    buffer *= factor;


    fwrite(&buffer, sizeof(int16_t), 1, output);
}
    fclose(input);
    fclose(output);

}
```

# week5 数据结构
队列和栈在我的数据结构和算法里面就学过了 这里跳过

链表 虽然也学过了 但在这里有一些新的理解

里面有一句我之前一只没c懂  现在看来就清晰多了
![image](https://github.com/user-attachments/assets/16b6414b-c261-4ab0-b579-23adbd89e1eb)
node *n = malloc(sizeof(node)) 这不就是开一个node大小的结构体吗

中间的树就跳过了

哈希表其实就是一个映射 f（x） 并且使用链表（重复）

### 字典树

