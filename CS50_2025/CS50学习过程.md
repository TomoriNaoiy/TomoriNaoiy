开始CS50的学习 从51开始 希望能在两个月内完成
=======================

# week1 C语言的入门

VSC编译器 究竟是在作什么？
实际上 我们使用code a.c 创建一个c语言的文件 然后通过make hello 将其转化为机器代码 然后再通过./hello 运行这段机器代码（由于是机器代码 我们无法看到 就算打开也只是乱码）

一些转义符的用法\n \r(光标移至行首而非下一行) \" \\ \' 可以打出实际的 “ ‘ \

几个命令
- cd 打开某个文件夹 文件
- cp 复制
- mkdir创建文件夹 类似mkdir a
- rm 删除 rm a 后面会询问你是否确认 输入y即可
- mv 移动 比如 mv hhh a 把hhh移到a文件夹里面

task mario
简单来说 就是做一个右对齐的金字塔 其实里面的创新点在于 输入一个数 如果不是符合 就再次重复 用到do while语句
do
{
int h;
cin>>h;

}
while(h<=0 or h>9);

# week2 array
这节课没啥内容 主要是一个 int main（）里面是可以传参数的 
int main（int arg）
这个时候在运行时就可以给予参数

加入文件为greet 则cmd里面输入./greet 10 就可以直接给参数了 一般来说时void

# week3 算法 
题目虽然是算法 但是实际上基本涉及很少 主要讲了三种排序 
1. 冒泡 懂的都懂 面对以及排序好的列表会很快 其他一般
2. 选择 都差不多
3. 归并 相对于前两个会快 毕竟是logn复杂度 通过递归 类似于二分 将43|16二分部 然后判断是否是单个数字 不是就继续分 然后对4 3排序 变成3 4 然后对16 变成1 6 最后根据3 和1 的大小分在第一和第二位

然后就是一些很简单的数组题目 不涉及什么算法 值得说的就是c语言里面只能strmp（） 不能== 有点蠢

# week4 记忆

先是提到指针 说到内存是根据16进制计算的 

%p，它允许我们查看内存中某个位置的地址。&n可以直译为“的地址n”。执行此代码将返回以 开头的内存地址0x。
```c
// Prints an integer's address

#include <stdio.h>

int main(void)
{
    int n = 50;
    printf("%p\n", &n);
}
```

指针是一个存储某个对象地址的变量。简而言之，指针就是计算机内存中的一个地址。
![image](https://github.com/user-attachments/assets/1e6d0758-1ded-4906-b523-b9defcac3e44)

总之 char *s=“HI！” s便是指向H的地址
```c
// Declares a string without CS50 Library

#include <stdio.h>

int main(void)
{
    char *s = "HI!";
    printf("%s\n", s);
}
```

因此在这里字符指针和字符数组有很大的相同点 但也有所区别
s[]="hi" 创建了一个大小由字符串长度决定的空间 

*s=“hi” 则是一个指向字符串的首地址的指针  并且只读 也就是说你无法通过s[0]=“1”改变 但是数组就可以

空间上来说 s[]是创建了一个新开辟的空间中 而指针则是在一个常量区

用法上 都可以使用s[0]下标进行获得元素
```c
/ Prints a string's chars via pointer arithmetic

#include <stdio.h>

int main(void)
{
    char *s = "HI!";
    printf("%c\n", *s);
    printf("%c\n", *(s + 1));
    printf("%c\n", *(s + 2));
}
```
因此在毕竟两个字符串时 ==比较的是两个字符串的地址 需要使用strmp

那么malloc和free有何用呢 

在我们需要复制一个字符串的时候 例如*s="666"；

那我们若要复制 就要开辟一个空间（不是数组） char *t=malloc(strlen(s)+1)

也就是说 在创造一个不止长度的s时 char*s=malloc（4） 和s[4]等价
当然我们有strcp(

```c
// Demonstrates memory errors via valgrind

#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    int *x = malloc(3 * sizeof(int));
    x[1] = 72;
    x[2] = 73;
    x[3] = 33;
    free(x);
}
```
为什么我们要是有sizeof（int）呢 其实直接写3就行 sizeof（int）获得一个int所占的字节 这行代码就是打开3歌int字节 这样写更方便看..

```c++
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    int scores[1024];
    for (int i = 0; i < 1024; i++)
    {
        printf("%i\n", scores[i]);
    }
}
```
这里如果运行 可能会出现一些逆天数值 那就是因为开辟的空间可能以及被占用 你又没有给新的值 因此出现奇奇怪怪的值

题目 第一题写了一个音频处理 主要是一些文件处理的格式 代码贴出来
```c
// Modifies the volume of an audio file

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>

// Number of bytes in .wav header
const int HEADER_SIZE = 44;

int main(int argc, char *argv[])
{
    // Check command-line arguments
    if (argc != 4)
    {
        printf("Usage: ./volume input.wav output.wav factor\n");
        return 1;
    }

    // Open files and determine scaling factor
    FILE *input = fopen(argv[1], "r");
    if (input == NULL)
    {
        printf("Could not open file.\n");
        return 1;
    }

    FILE *output = fopen(argv[2], "w");
    if (output == NULL)
    {
        printf("Could not open file.\n");
        return 1;
    }

    float factor = atof(argv[3]);

    // TODO: Copy header from input file to output file
    uint8_t header[HEADER_SIZE];
    fread(header, HEADER_SIZE, 1, input);
    fwrite(header, HEADER_SIZE, 1, output);
    // TODO: Read samples from input file and write updated data to output file
    int16_t buffer;

// Read single sample from input into buffer while there are samples left to read
    while (fread(&buffer, sizeof(int16_t), 1, input))
    {

    buffer *= factor;


    fwrite(&buffer, sizeof(int16_t), 1, output);
}
    fclose(input);
    fclose(output);

}
```

# week5 数据结构
队列和栈在我的数据结构和算法里面就学过了 这里跳过

链表 虽然也学过了 但在这里有一些新的理解

里面有一句我之前一只没c懂  现在看来就清晰多了
![image](https://github.com/user-attachments/assets/16b6414b-c261-4ab0-b579-23adbd89e1eb)
node *n = malloc(sizeof(node)) 这不就是开一个node大小的结构体吗

中间的树就跳过了
哈希表其实就是一个映射 f（x） 并且使用链表（重复）
### 字典树

#week6 python
不必提 直接跳过
# week7  SQL
先提出了csv文件中的csvreader
```python
# Prints all favorites in CSV using csv.reader

import csv

# Open CSV file
with open("favorites.csv", "r") as file:

    # Create reader
    reader = csv.reader(file)

    # Skip header row
    next(reader)

    # Iterate over CSV file, printing each favorite
    for row in reader:
        print(row[1])
```
注意 这里的reader是一个迭代器 

每次调用 next(reader) 或使用 for row in reader 时，它会返回 CSV 文件中的一行数据，并将其解析为一个列表（list 类型）。

**值得一提的是** file同样也是一个可迭代的文件类型 同样可以通过遍历的方法获得每一行 但是这里的row是str类型而非list 我们可以主动split（）转化并且是直接操作文件 同样可以通过read()、readline() 或 readlines()等方法获得元素（获得的是列表 可以下标操作）

### next（） 什么用呢？ 字面意思 next 跳过第一行咯...

下一个
```python
# Prints all favorites in CSV using csv.DictReader

import csv

# Open CSV file
with open("favorites.csv", "r") as file:

    # Create DictReader
    reader = csv.DictReader(file)

    # Iterate over CSV file, printing each favorite
    for row in reader:
        favorite = row["language"]
        print(favorite)
```
非常好用的一个方法 可以将数据处理变得机器容易
![image](https://github.com/user-attachments/assets/260a9952-6c2a-4a7c-ab74-c5e7ac17770f)
![image](https://github.com/user-attachments/assets/c498a66f-0f63-43de-a22f-746182d42fae)
创造性的将标题做为字典的键 对于后续的处理有极大的帮助 注意 这里reader同样也是迭代器 遍历的时候才是字典（每一行）

这里提了一嘴sort和sorted的区别

循环的时候 for i in range（sorted（list）） 这里是获得一个排序的列表 而非对列表直接操作

list.sort()直接操作 不返回值 

**reverse**也同理

### SQL
- Create
-  Read
-  Update
-  Delete

CRUD

大体学下来 类似一门新的语言 但是结合了python和c（；） 

cs50中使用sqlite3

1. 创建sql数据库 sqlite3 faverote.db
2. 进入csv模式 .mode csv
3. 导入csv文件 .import favorite.csv favorites 不会有啥反应  但是这是好事
4. 输入.schema看数据库
5. 标准语法 SELETE columns FROM table 例如 SELECT *(全部) FRI favirutes (打印每一行)
6. SELECT language(language是一个标题) FROM favorites;(分号捏 这是c)
   
### SELECT

![image](https://github.com/user-attachments/assets/f6204358-cf20-40b7-bce2-373b419df56f)

一些用法 比如SELECT COUNT(*) FROM favorite; (行数)

或者SELECT COUNT(DISTINCT language) FROM favorites;（DISTINCT）是去重  相当于数种类的数量
 -  **WHERE**       -- adding a Boolean expression to filter our data

  - eg:SELECT COUNT(*) FROM favorites WHERE language ='c' AND problem ='hellow,world';(类似一个定位符？)
    
  - **LIKE**       -- filtering responses more loosely

  - 类似正则表达式匹配 例如 SELECT COUNT(*) FROM fav... WHERE problem LIKE ='hello,%'; 
  
  - **ORDER BY**    -- ordering responses 排序 不用说

  - SELECT language FROM favorite GROUP BY language ORDER BY COUNT(*)
  
  - **LIMIT**       -- limiting the number of responses 很好理解 例如 排序后只拿第一个？

 -  SELECT language COUNT(*) .......LIMIT 1；
  
  - **GROUP BY**    -- grouping responses together 

  - 学过pandas的应该很好懂 by group 将相同的分组 精选数据分析 

  - SELECT language 
  - (*) FROM favorites GROUP BY language；

```SQL
--顺带一提 SQL语法里面用--注释
```
### INSERT

- INSERT INTO table VALUES（标准语法）

- eg INSERT INTO favorites(language,problem) VALUES('SQL','Fiftyville');

- 得到的结果是 NULL SQL Fiftyville(第一列没给)

### DELETE
- DELETE FROM favorites;全部删掉

- DELETE FROM favorites WHERE Timestamp IS NULL;

这样就删掉了刚才那一行

### UPDATE

- UPDATE table SET column = value WHERE condition;

- UPDATE favorites SET language ='SQL' ,problem='fIRFTYVILLE';
**危险等级！！！** 这样做就把所有的都改成SQL 和fifty了...
  


