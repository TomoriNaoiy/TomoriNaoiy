# asyncio
什么是异步  
比如 在进行网络爬虫的时候 如果进行video的下载 这个时候任务就停在了进行下载的过程 无法继续进行下面的任务的进行 那么这个时候就需要异步操作 将在进行这个操作的时候 同时进行其他操作
# async
asyncio里面最重要的关键字之一  作用是将函数定义为一个异步函数  
那么在调用这个函数时 会返回一个协程对象 而非调用该函数  
那么如果运行的 就需要把这个协程对象包装成一个task 然后才能在事件循环（even loop）  里面进行调度
那么如何从协程->task呢  
**就是我们的asyncio.run()里面的参数应该是一个协程对象 例如刚才的main（）**

### 那么做为异步操作 在even loop里面只运行一个task 就没有任何意义了 因此我们的目标是 在even loop中 创建多个task 然后判断应该什么时候运行那个task
# await
asyncio里面最关键的关键字之一   
能够将协程变成task
```py
async def say(a,b):
  await asyncio.sleep()
  print()
async def main():
  print()
  await say(1)
  await say(2)
  print()
asyncio.run(main())
```
这段代码的思路时 首先调度main这个协程 然后进入main函数中 将say（1）变成task 然后放入even loop里面 然后由其决定 然后等待一秒后 完成这个task 只剩main  然后在进行say（2） 最后完成

但是目前这样的写法 和同步没有区别 因此我们进行优化
```py
async def say(a,b):
  await asyncio.sleep()
  print()
async def main():
  print()
   task1=asyncio.creat_task(say(1))
  task2=asyncio.creat_task(say(2))
await tas1
await task2
  print()
asyncio.run(main())
```
我们需要引入一个新的方法 就是 asyncio.creat_task(协程对象) 这样做可以把一个协程对象变成一个task 同时放入even loop

那么在这段代码的区别就是 上一个代码是 在做main的时候 将say（1）await 放入even loop 然后必须等待say（1）完成后 才把say（2）变成task 放入 效果并不好 但是这段代码是 在main的时候 就把say（1） say（2）同时变成了task 在等待task1完成的同时 cpu闲来无事 就发现可以同时完成task2  因此两个操作就可以同时进行了

### 那么到现在 异步操作的基本以及弄懂了 接下来又有一个问题 如果同时有多个task呢？我需要写好多个await嘛

# gather方法
```
await asyncio.gather(task1,task2)
```
这句话就相当于 await要等到里面所有的task完成 才能继续 也就省略了许多await的重复
